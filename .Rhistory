rowB <- ifelse(is.na(rowB), 0, 1)
s_user <- diag(x = 1, 2,2)
s_obj <- diag(x = 1, length(rowA), length(rowB))
p_user <- rowA %*% t(rowB)
len_x <- sum(rowA)
len_y <- sum(rowB)
for(k in 1:(K+1)){
# Calculate s_user
s_user[1,2]=s_user[2,1] <- sum(s_obj * p_user)*C1/(len_x*len_y)
# Now update s_obj
for(row_i in 1:nrow(s_obj)){
for(col_j in 1:ncol(s_obj)){
if(row_i == col_j){
s_obj[row_i, col_j] <- 1
}else{
I_a <- as.vector(c(rowA[[row_i]],rowB[[row_i]]))
I_b <- as.vector(c(rowA[[col_j]], rowB[[col_j]]))
p_obj <- I_a %*% t(I_b)
s_obj[row_i, col_j] <- sum(s_user * p_obj) * C2/(sum(I_a) * sum(I_b))
}
}
}
}
rowA <- as.vector(c(NA, 1))
rowB <- as.vector(c(1, NA))
j <- !is.na(rowA) | !is.na(rowB)
rowA <- rowA[j]
rowB <- rowB[j]
rowA <- ifelse(is.na(rowA), 0, 1)
rowB <- ifelse(is.na(rowB), 0, 1)
s_user <- diag(x = 1, 2,2)
s_obj <- diag(x = 1, length(rowA), length(rowB))
p_user <- rowA %*% t(rowB)
len_x <- sum(rowA)
len_y <- sum(rowB)
for(k in 1:(K+1)){
# Calculate s_user
s_user[1,2]=s_user[2,1] <- sum(s_obj * p_user)*C1/(len_x*len_y)
# Now update s_obj
for(row_i in 1:nrow(s_obj)){
for(col_j in 1:ncol(s_obj)){
if(row_i == col_j){
s_obj[row_i, col_j] <- 1
}else{
I_a <- as.vector(c(rowA[[row_i]],rowB[[row_i]]))
I_b <- as.vector(c(rowA[[col_j]], rowB[[col_j]]))
p_obj <- I_a %*% t(I_b)
s_obj[row_i, col_j] <- sum(s_user * p_obj) * C2/(sum(I_a) * sum(I_b))
}
}
}
}
score <- s_user[1,2]
calc_weight <- function(data, run.pearson=F, run.entropy=F, run.spearman=F, run.sqdiff=F, run.cosin = F, run.sim) {
## Calculate similarity weight matrix
##
## input: data   - movie data or MS data in user-item matrix form
##        method - 'pearson'
##
## output: similarity weight matrix
# Iniate the similarity weight matrix
data       <- as.matrix(data)
weight_mat <- matrix(NA, nrow = nrow(data), ncol = nrow(data))
weight_func <- function(rowA, rowB) {
# weight_func takes as input two rows (thought of as rows of the data matrix) and
# calculates the similarity between the two rows according to 'method'
joint_values <- !is.na(rowA) & !is.na(rowB)
if (sum(joint_values) == 0) {
return(0)
} else {
if (run.pearson) {
return(cor(rowA[joint_values], rowB[joint_values], method = 'pearson'))
}
if (run.entropy) {
library("infotheo")
return(mutinformation(rowA[joint_values], rowB[joint_values], method = 'emp'))
}
if (run.spearman) {
return(cor(rowA[joint_values], rowB[joint_values], method = 'spearman'))
}
if (run.sqdiff) {
return(mean((rowA[joint_values]-rowB[joint_values])^2))
}
if(run.cosin){
if(!require("lsa")){
install.packages("lsa")
}
library("lsa")
stand_rowA <- as.vector(scale(rowA[joint_values]))
stand_rowB <- as.vector(scale(rowB[joint_values]))
return(cosine(stand_rowA, stand_rowB))
}
if(run.sim){
j <- !is.na(rowA) | !is.na(rowB)
rowA <- rowA[j]
rowB <- rowB[j]
if(length(rowA) <= 1){
score <- 0
}else{
# Convert to 1/0 vector
rowA <- ifelse(is.na(rowA), 0, 1)
rowB <- ifelse(is.na(rowB), 0, 1)
# First construct the user and object score matrix
s_user <- diag(x = 1, 2,2)
s_obj <- diag(x = 1, length(rowA), length(rowB))
p_user <- rowA %*% t(rowB)
# Find |O(X)|,|O(Y)|
len_x <- sum(rowA)
len_y <- sum(rowB)
# Iteratively update the scores of user and objects
for(k in 1:(K+1)){
# Calculate s_user
s_user[1,2]=s_user[2,1] <- sum(s_obj * p_user)*C1/(len_x*len_y)
# Now update s_obj
for(row_i in 1:nrow(s_obj)){
for(col_j in 1:ncol(s_obj)){
if(row_i == col_j){
s_obj[row_i, col_j] <- 1
}else{
I_a <- as.vector(c(rowA[[row_i]],rowB[[row_i]]))
I_b <- as.vector(c(rowA[[col_j]], rowB[[col_j]]))
p_obj <- I_a %*% t(I_b)
s_obj[row_i, col_j] <- sum(s_user * p_obj) * C2/(sum(I_a) * sum(I_b))
}
}
}
}
score <- s_user[1,2]
}
return(score)
}
}
}
# Loops over the rows and calculate sall similarities using weight_func
for(i in 1:nrow(data)) {
weight_mat[i, ] <- apply(data, 1, weight_func, data[i, ])
print(i)
}
return(round(weight_mat, 4))
}
calc_weight(movie_UI[1:10,], run.sim = T)
rowA <- movie_UI[1,]
rowB <- movie_UI[2,]
j <- !is.na(rowA) | !is.na(rowB)
rowA <- rowA[j]
rowB <- rowB[j]
if(length(rowA) <= 1){
score <- 0
}else{
# Convert to 1/0 vector
rowA <- ifelse(is.na(rowA), 0, 1)
rowB <- ifelse(is.na(rowB), 0, 1)
# First construct the user and object score matrix
s_user <- diag(x = 1, 2,2)
s_obj <- diag(x = 1, length(rowA), length(rowB))
p_user <- rowA %*% t(rowB)
# Find |O(X)|,|O(Y)|
len_x <- sum(rowA)
len_y <- sum(rowB)
# Iteratively update the scores of user and objects
for(k in 1:(K+1)){
# Calculate s_user
s_user[1,2]=s_user[2,1] <- sum(s_obj * p_user)*C1/(len_x*len_y)
# Now update s_obj
for(row_i in 1:nrow(s_obj)){
for(col_j in 1:ncol(s_obj)){
if(row_i == col_j){
s_obj[row_i, col_j] <- 1
}else{
I_a <- as.vector(c(rowA[[row_i]],rowB[[row_i]]))
I_b <- as.vector(c(rowA[[col_j]], rowB[[col_j]]))
p_obj <- I_a %*% t(I_b)
s_obj[row_i, col_j] <- sum(s_user * p_obj) * C2/(sum(I_a) * sum(I_b))
}
}
}
}
score <- s_user[1,2]
}
system.time(calc_weight(movie_UI[1:10,], run.sim = T))
weight_func <- function(rowA, rowB){
j <- !is.na(rowA) | !is.na(rowB)
rowA <- rowA[j]
rowB <- rowB[j]
if(length(rowA) <= 1){
score <- 0
}else{
# Convert to 1/0 vector
rowA <- ifelse(is.na(rowA), 0, 1)
rowB <- ifelse(is.na(rowB), 0, 1)
# First construct the user and object score matrix
s_user <- diag(x = 1, 2,2)
s_obj <- diag(x = 1, length(rowA), length(rowB))
p_user <- rowA %*% t(rowB)
# Find |O(X)|,|O(Y)|
len_x <- sum(rowA)
len_y <- sum(rowB)
# Iteratively update the scores of user and objects
for(k in 1:(K+1)){
# Calculate s_user
s_user[1,2]=s_user[2,1] <- sum(s_obj * p_user)*C1/(len_x*len_y)
# Now update s_obj
for(row_i in 1:nrow(s_obj)){
for(col_j in 1:ncol(s_obj)){
if(row_i == col_j){
s_obj[row_i, col_j] <- 1
}else{
I_a <- as.vector(c(rowA[[row_i]],rowB[[row_i]]))
I_b <- as.vector(c(rowA[[col_j]], rowB[[col_j]]))
p_obj <- I_a %*% t(I_b)
s_obj[row_i, col_j] <- sum(s_user * p_obj) * C2/(sum(I_a) * sum(I_b))
}
}
}
}
score <- s_user[1,2]
}
}
data       <- as.matrix(movie_UI)
weight_mat <- matrix(NA, nrow = nrow(data), ncol = nrow(data))
data       <- as.matrix(movie_UI[1:10,])
weight_mat <- matrix(NA, nrow = nrow(data), ncol = nrow(data))
weight_func <- function(rowA, rowB) {
# weight_func takes as input two rows (thought of as rows of the data matrix) and
# calculates the similarity between the two rows according to 'method'
joint_values <- !is.na(rowA) & !is.na(rowB)
return(cor(rowA[joint_values], rowB[joint_values], method = 'pearson'))
}
apply(data,1,weight_func, data[1,])
?apply
apply(data,1,weight_func, data[2,])
apply(data,1,weight_func)
?mean
apply(data[2:nrow(data),],1,weight_func, data[2,])
apply(data[2:nrow(data),],1,weight_func, data[1,])
apply(data[3:nrow(data),],1,weight_func, data[2,])
weight_func <- function(rowA, rowB) {
# weight_func takes as input two rows (thought of as rows of the data matrix) and
# calculates the similarity between the two rows according to 'method'
joint_values <- !is.na(rowA) & !is.na(rowB)
return(cor(rowA[joint_values], rowB[joint_values], method = 'pearson'))
}
for(i in 1:nrow(data)) {
weight_mat[i, ] <- apply(data, 1, weight_func, data[i, ])
print(i)
}
View(weight_mat)
weight_mat2 <- weight_mat
for(i in 1:nrow(data)) {
for(j in i:nrow(data)){
weight_mat[i, ] <- apply(data[j:nrow(data),], 1, weight_func, data[i, ])
print(i)
}
}
apply(data[3:nrow(data),],1,weight_func, data[2,])
temp <- apply(data[3:nrow(data),],1,weight_func, data[2,])
temp <- c(rep(NA, 2), temp)
for(i in 1:nrow(data)) {
for(j in i:nrow(data)){
weight_mat[i, ] <- c(rep(NA, i-1),apply(data[j:nrow(data),], 1, weight_func, data[i, ]))
print(i)
}
}
i <- 2
j <- 2
rep(NA, i-1)
rep(NA, i-2)
rep(NA, i+1)
c(rep(NA, i-1),apply(data[j:nrow(data),], 1, weight_func, data[i, ]))
j <- 3
c(rep(NA, i-1),apply(data[j:nrow(data),], 1, weight_func, data[i, ]))
for(i in 1:nrow(data)) {
for(j in i:nrow(data)){
weight_mat[i, ] <- c(rep(NA, j-1),apply(data[j:nrow(data),], 1, weight_func, data[i, ]))
print(i)
}
}
for(i in 1:nrow(data)) {
for(j in i:nrow(data)){
weight_mat[i, ] <- c(rep(NA, j-1),apply(data[j:nrow(data),], 1, weight_func, data[i, ]))
print(j)
}
}
temp <- apply(data[10:nrow(data),],1,weight_func, data[1,])
nrow(data)
data[10:10,]
temp <- data[10:10,]
apply(data[10:10,], 1, mean)
dim(data[10:10,])
dim(data[9:10,])
apply(as.matrix(data[10:10,]), 1, mean)
for(i in 1:nrow(data)) {
weight_mat[i, ] <- c(rep(NA, i-1),apply(data[i:nrow(data),], 1, weight_func, data[i, ]))
print(j)
}
for(i in 1:nrow(data)) {
weight_mat[i, ] <- c(rep(NA, i-1),apply(as.matrix(data[i:nrow(data),]), 1, weight_func, data[i, ]))
print(j)
}
apply(data[1:nrow(data),],1,weight_func, data[1,])
for(i in 1:nrow(data)) {
weight_mat[i, ] <- c(rep(NA, i-1),apply(as.matrix(data[i:nrow(data),]), 1, weight_func, data[i, ]))
print(i)
}
rep(NA, 9)
temp <- apply(as.matrix(data[10:nrow(data),]),1,weight_func, data[1,])
typeof(data[9:10,])
temp <- as.integer(data[10:10,])
for(i in 1:(nrow(data)-1)) {
weight_mat[i:nrow(data), ] <- apply(data[i:nrow(data),], 1, weight_func, data[i, ])
print(i)
}
View(weight_mat)
View(weight_mat)
data       <- as.matrix(movie_UI[1:10,])
weight_mat <- matrix(NA, nrow = nrow(data), ncol = nrow(data))
weight_mat2 <- weight_mat
for(i in 1:nrow(data)) {
weight_mat[i, ] <- apply(data, 1, weight_func, data[i, ])
print(i)
}
View(weight_mat)
for(i in 1:(nrow(data)-1)) {
weight_mat2[i:nrow(data), ] <- apply(data[i:nrow(data),], 1, weight_func, data[i, ])
print(i)
}
View(weight_mat2)
weight_mat2[i, i:nrow(data) ] <- apply(data[i:nrow(data),], 1, weight_func, data[i, ])
View(weight_mat2)
apply(data[i:nrow(data),], 1, weight_func, data[i, ])
i <- 1
weight_mat2[i, i:nrow(data) ] <- apply(data[i:nrow(data),], 1, weight_func, data[i, ])
View(weight_mat2)
weight_mat <- matrix(NA, nrow = nrow(data), ncol = nrow(data))
weight_mat2 <- weight_mat
weight_mat2[i, i:nrow(data) ] <- apply(data[i:nrow(data),], 1, weight_func, data[i, ])
View(weight_mat2)
View(weight_mat)
for(i in 1:nrow(data)) {
weight_mat[i, ] <- apply(data, 1, weight_func, data[i, ])
print(i)
}
View(weight_mat)
for(i in 1:(nrow(data)-1)) {
weight_mat2[i, i:nrow(data) ] <- apply(data[i:nrow(data),], 1, weight_func, data[i, ])
print(i)
}
View(weight_mat2)
weight_mat2 <- diag(x = 1, nrow(data), nrow(data))
for(i in 1:(nrow(data)-1)) {
weight_mat2[i, i:nrow(data) ] <- apply(data[i:nrow(data),], 1, weight_func, data[i, ])
print(i)
}
View(weight_mat2)
system.time(
for(i in 1:(nrow(data)-1)) {
weight_mat2[i, i:nrow(data) ] <- apply(data[i:nrow(data),], 1, weight_func, data[i, ])
print(i)
}
)
system.time(
for(i in 1:nrow(data)) {
weight_mat[i, ] <- apply(data, 1, weight_func, data[i, ])
print(i)
}
)
weight_func <- function(rowA, rowB){
j <- !is.na(rowA) | !is.na(rowB)
rowA <- rowA[j]
rowB <- rowB[j]
if(length(rowA) <= 1){
score <- 0
}else{
# Convert to 1/0 vector
rowA <- ifelse(is.na(rowA), 0, 1)
rowB <- ifelse(is.na(rowB), 0, 1)
# First construct the user and object score matrix
s_user <- diag(x = 1, 2,2)
s_obj <- diag(x = 1, length(rowA), length(rowB))
p_user <- rowA %*% t(rowB)
# Find |O(X)|,|O(Y)|
len_x <- sum(rowA)
len_y <- sum(rowB)
# Iteratively update the scores of user and objects
for(k in 1:(K+1)){
# Calculate s_user
s_user[1,2]=s_user[2,1] <- sum(s_obj * p_user)*C1/(len_x*len_y)
# Update s_obj
for(row_i in 1:nrow(s_obj)){
for(col_j in 1:ncol(s_obj)){
if(row_i == col_j){
s_obj[row_i, col_j] <- 1
}else{
I_a <- as.vector(c(rowA[[row_i]],rowB[[row_i]]))
I_b <- as.vector(c(rowA[[col_j]], rowB[[col_j]]))
p_obj <- I_a %*% t(I_b)
s_obj[row_i, col_j] <- sum(s_user * p_obj) * C2/(sum(I_a) * sum(I_b))
}
}
}
}
score <- s_user[1,2]
}
}
system.time(
for(i in 1:(nrow(data)-1)) {
weight_mat2[i, i:nrow(data) ] <- apply(data[i:nrow(data),], 1, weight_func, data[i, ])
print(i)
}
)
data       <- as.matrix(movie_UI[1:5,])
weight_mat <- matrix(NA, nrow = nrow(data), ncol = nrow(data))
weight_mat2 <- diag(x = 1, nrow(data), nrow(data))
system.time(
for(i in 1:(nrow(data)-1)) {
weight_mat2[i, i:nrow(data) ] <- apply(data[i:nrow(data),], 1, weight_func, data[i, ])
print(i)
}
)
data       <- as.matrix(movie_UI[1:2,])
weight_mat <- matrix(NA, nrow = nrow(data), ncol = nrow(data))
weight_mat2 <- diag(x = 1, nrow(data), nrow(data))
system.time(
for(i in 1:(nrow(data)-1)) {
weight_mat2[i, i:nrow(data) ] <- apply(data[i:nrow(data),], 1, weight_func, data[i, ])
print(i)
}
)
rowA <- movie_UI[1,]
rowB <- movie_UI[2,]
weight_func(rowA, rowB)
weight_func <- function(rowA, rowB){
j <- !is.na(rowA) | !is.na(rowB)
rowA <- rowA[j]
rowB <- rowB[j]
if(length(rowA) <= 1){
score <- 0
}else{
# Convert to 1/0 vector
rowA <- ifelse(is.na(rowA), 0, 1)
rowB <- ifelse(is.na(rowB), 0, 1)
# First construct the user and object score matrix
s_user <- diag(x = 1, 2,2)
s_obj <- diag(x = 1, length(rowA), length(rowB))
p_user <- rowA %*% t(rowB)
# Find |O(X)|,|O(Y)|
len_x <- sum(rowA)
len_y <- sum(rowB)
# Iteratively update the scores of user and objects
for(k in 1:(K+1)){
# Calculate s_user
s_user[1,2]=s_user[2,1] <- sum(s_obj * p_user)*C1/(len_x*len_y)
# Update s_obj
for(row_i in 1:nrow(s_obj)){
for(col_j in 1:ncol(s_obj)){
if(row_i == col_j){
s_obj[row_i, col_j] <- 1
}else{
I_a <- as.vector(c(rowA[[row_i]],rowB[[row_i]]))
I_b <- as.vector(c(rowA[[col_j]], rowB[[col_j]]))
p_obj <- I_a %*% t(I_b)
s_obj[row_i, col_j] <- sum(s_user * p_obj) * C2/(sum(I_a) * sum(I_b))
}
}
}
}
score <- s_user[1,2]
}
return(score)
}
weight_func(rowA, rowB)
system.time(weight_func(rowA, rowB))
?Matrix::forceSymmetric
data       <- as.matrix(movie_UI[1:10,])
weight_mat <- matrix(NA, nrow = nrow(data), ncol = nrow(data))
weight_mat2 <- diag(x = 1, nrow(data), nrow(data))
weight_func <- function(rowA, rowB) {
# weight_func takes as input two rows (thought of as rows of the data matrix) and
# calculates the similarity between the two rows according to 'method'
joint_values <- !is.na(rowA) & !is.na(rowB)
return(cor(rowA[joint_values], rowB[joint_values], method = 'pearson'))
}
system.time(
for(i in 1:(nrow(data)-1)) {
weight_mat2[i, i:nrow(data) ] <- apply(data[i:nrow(data),], 1, weight_func, data[i, ])
print(i)
}
)
View(weight_mat2)
Matrix::forceSymmetric(weight_mat2, uplo = "U")
weight_mat2 <- Matrix::forceSymmetric(weight_mat2, uplo = "U")
t
for(i in 1:(nrow(data)-1)) {
weight_mat2[i, i:nrow(data) ] <- apply(data[i:nrow(data),], 1, weight_func, data[i, ])
print(i)
}
weight_mat3 <- as.matrix(Matrix::forceSymmetric(weight_mat2, uplo = "U"))
View(weight_mat3)
setwd("/Users/Kai Li/Documents/GitHub/project-3-algorithms-project-3-algorithms-group-2")
setwd("/Users/wcheng/Desktop/Spring 2018/data science/project-3-algorithms-project-3-algorithms-group-2")
source("./lib/functions.R")
source("./lib/functions.R")
load("./output/MS_UI.Rdata")
load("./output/movie_UI.Rdata")
load("./output/MS_sqd.Rdata")
MS_pred <- pred_matrix(MS_UI, MS_sqd)
i
MS_pred_sqd <- pred_matrix(MS_UI, MS_sqd)
save(MS_pred_sqd, file = "./output/MS_pred_sqd.RData")
movie_pred_sqd <- pred_matrix(movie_UI, movie_sqd)
load("./output/movie_sqd.Rdata")
movie_pred_sqd <- pred_matrix(movie_UI, movie_sqd)
